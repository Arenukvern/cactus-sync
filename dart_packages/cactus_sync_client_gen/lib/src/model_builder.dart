import 'dart:async';

import 'package:build/build.dart';
import 'package:cactus_sync_client_gen/src/gql_enum.dart';
import 'package:cactus_sync_client_gen/src/gql_input_converter.dart';
import 'package:cactus_sync_client_gen/src/gql_model_builder.dart';
import 'package:gql/language.dart' as gql_lang;
import "package:gql/schema.dart" as gql_schema;
import 'package:indent/indent.dart';

class ModelBuilder implements Builder {
  @override
  FutureOr<void> build(BuildStep buildStep) async {
    // Retrieve the currently matched asset
    final inputId = buildStep.inputId;

    /// Create new target
    final copyAssetId = inputId.changeExtension('.dart');
    final originContentStr = await buildStep.readAsString(inputId);
    final schemaDocument = gql_lang.parseString(originContentStr);
    final schema = gql_schema.buildSchema(schemaDocument);
    // TODO: add operation types
    // TODO: add enums

    // TODO: add scalars
    final finalModels = StringBuffer();
    final operationTypes = schema.typeMap;
    final modelsAndProviders = GqlModelBuilder().makeModelsAndProviders(
      operationTypes: operationTypes.values,
    );

    finalModels.writeln(modelsAndProviders);

    final inputClasses = GqlInputs().fromSchema(
      inputObjectTypes: schema.inputObjectTypes,
    );
    finalModels.writeln(inputClasses);

    final dartEnums = GqlEnums.fromSchema(
      schemaEnums: schema.enums,
    );
    finalModels.writeln(dartEnums);
    final finalBuffer = StringBuffer(
      """
        import 'package:cactus_sync_client/cactus_sync_client.dart';
        import 'package:riverpod/riverpod.dart';
        import 'package:built_value/built_value.dart';
        /// !------------ CAUTION ------------!
        /// Autogenerated file. Please do not edit it manually!
        /// Updated: ${DateTime.now()}
        /// !---------- END CAUTION ----------!
      """
          .unindent(),
    );
    finalBuffer.writeln(finalModels);
    final finalContent = finalBuffer.toString();

    await buildStep.writeAsString(copyAssetId, finalContent.unindent());
  }

  @override
  Map<String, List<String>> get buildExtensions => {
        '.graphql': [".dart"]
      };
}

// interface PluginConfig {
//   withVueState?: boolean
//   schemaTypesPath?: string
//   useDefaultFragments?: boolean
//   defaultFragmentsPath?: string
//   modelsGraphqlSchemaPath?: string
//   cactusSyncConfigPath?: string
//   cactusSyncConfigHookName?: string
// }

// const toCamelCase = (str: string) => {
//   const first = str[0].toLowerCase()
//   const rest = str.substring(1)
//   return `${first}${rest}`
// }
// async (schema: GraphQLSchema, _documents, config: PluginConfig) {
//     // ============== Config settings ======================

//     const {
//       withVueState,
//       schemaTypesPath,
//       useDefaultFragments,
//       defaultFragmentsPath,
//       modelsGraphqlSchemaPath,
//       cactusSyncConfigPath,
//       cactusSyncConfigHookName,
//     } = config
//     const importVueStateModel = withVueState ? ', VueStateModel' : ''
//     const typesPath = schemaTypesPath ?? './generatedTypes'
//     const fragmentsPath = defaultFragmentsPath ?? '../gql'
//     const graphqlSchemaPath = modelsGraphqlSchemaPath ?? './models.graphql?raw'
//     const configPath = cactusSyncConfigPath ?? './config'
//     const configHookName = cactusSyncConfigHookName ?? 'useCactusSyncInit'
//     // ============ Filtering types only ====================

//     const types = Object.values(schema.getTypeMap()).filter((el) =>
//       isObjectType(el)
//     )
//     const exportModelStrings: string[] = []
//     const typesModels: string[] = []
//     const fragments: string[] = []
//     for (const type of types) {

//       const args = [
//         mutationCreateArgs,
//         mutationUpdateArgs,
//         mutationDeleteArgs,
//         queryGetArgs,
//         queryFindArgs,
//         queryFindResult,
//       ]
//       typesModels.push(...args, name)

//       const modelName = `${camelName}Model`

//       // ============ Model generation ====================
//       const defaultFragmentName = `${name}Fragment`
//       const defaultFragment = (() => {
//         if (useDefaultFragments) {
//           fragments.push(defaultFragmentName)
//           return `, defaultModelFragment: ${defaultFragmentName}`
//         } else {
//           return ''
//         }
//       })()
//       let modelStr = endent`
//       export const ${modelName}= CactusSync.attachModel(
//         CactusModel.init<
//           ${name},
//           ${mutationCreateArgs},
//           ${mutationCreateResult},
//           ${mutationUpdateArgs},
//           ${mutationUpdateResult},
//           ${mutationDeleteArgs},
//           ${mutationDeleteResult},
//           ${queryGetArgs},
//           ${queryGetResult},
//           ${queryFindArgs},
//           ${queryFindResultI}
//         >({ graphqlModelType: schema.getType('${name}') as Maybe<GraphQLObjectType> ${defaultFragment}})
//       )
//       `
//       if (withVueState) {
//         modelStr = endent`
//           ${modelStr}
//           export const use${name}State = () => new VueStateModel({ cactusModel: ${modelName} })
//           export type ${name}State = VueStateModel<
//               ${name},
//               ${mutationCreateArgs},
//               ${mutationCreateResult},
//               ${mutationUpdateArgs},
//               ${mutationUpdateResult},
//               ${mutationDeleteArgs},
//               ${mutationDeleteResult},
//               ${queryGetArgs},
//               ${queryGetResult},
//               ${queryFindArgs},
//               ${queryFindResultI}
//             >
//         `
//       }
//       exportModelStrings.push(modelStr)
//     }

//     const modelsExportStr = exportModelStrings.join('\n')
//     const fragmentsImportStr = useDefaultFragments
//       ? endent`import {${fragments.join(',\n')}} from '${fragmentsPath}'`
//       : ''
//     return endent`

//       /* eslint-disable */
//       import { GraphQLObjectType, buildSchema } from 'graphql'
//       ${fragmentsImportStr}
//       import { ${typesModels.join(' ,\n ')} } from '${typesPath}'
//       import { CactusSync, CactusModel ${importVueStateModel}, Maybe } from '@xsoulspace/cactus-sync-client'
//       import strSchema from '${graphqlSchemaPath}'
//       import {${configHookName}} from '${configPath}'

//       ${configHookName}()

//       const schema = buildSchema(strSchema)

//       ${modelsExportStr}

//       console.log('Cactus Sync hooks initialized')

//     `
// }
