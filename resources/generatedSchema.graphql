## NOTE: This schema was generated by Graphback and should not be changed manually

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

"""
@model
@cactusSync
This model keeps all changes for every model any made
FIXME: Maybe schema needs to work this way (first open, after offline):
client queried CactusSyncTimestamp first.
If new timestamps occured, then request changes
"""
type CactusSyncTimestamp {
  _id: GraphbackObjectID!

  """
  The id, which will be created, if
  the model was created offline
  """
  _clientId: GraphbackObjectID
  timestamp: Int
  changeType: DatabaseChangeType!
  modelTypename: String
  modelId: GraphbackObjectID!
}

input CactusSyncTimestampFilter {
  _id: GraphbackObjectIDInput
  _clientId: GraphbackObjectIDInput
  timestamp: IntInput
  changeType: StringInput
  modelTypename: StringInput
  modelId: GraphbackObjectIDInput
  and: [CactusSyncTimestampFilter!]
  or: [CactusSyncTimestampFilter!]
  not: CactusSyncTimestampFilter
}

type CactusSyncTimestampResultList {
  items: [CactusSyncTimestamp]!
  offset: Int
  limit: Int
  count: Int
}

input CactusSyncTimestampSubscriptionFilter {
  and: [CactusSyncTimestampSubscriptionFilter!]
  or: [CactusSyncTimestampSubscriptionFilter!]
  not: CactusSyncTimestampSubscriptionFilter
  _id: GraphbackObjectIDInput
  _clientId: GraphbackObjectIDInput
  timestamp: IntInput
  changeType: StringInput
  modelTypename: StringInput
  modelId: GraphbackObjectIDInput
}

input CreateCactusSyncTimestampInput {
  _clientId: GraphbackObjectID
  timestamp: Int
  changeType: DatabaseChangeType!
  modelTypename: String
  modelId: GraphbackObjectID!
}

input CreateTodoInput {
  _clientId: GraphbackObjectID
  _version: Int!
  _lastUpdatedAt: Int!
  title: String
  userId: GraphbackObjectID
}

input CreateUserInput {
  _clientId: GraphbackObjectID
  _version: Int!
  _lastUpdatedAt: Int!
  name: String
}

"""Named according to spec: https://graphql-rules.com/rules/naming-enum"""
enum DatabaseChangeType {
  CREATE
  UPDATE
  DELETE
}

scalar GraphbackObjectID

input GraphbackObjectIDInput {
  ne: GraphbackObjectID
  eq: GraphbackObjectID
  le: GraphbackObjectID
  lt: GraphbackObjectID
  ge: GraphbackObjectID
  gt: GraphbackObjectID
  in: [GraphbackObjectID!]
  between: [GraphbackObjectID!]
}

input IntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  in: [Int!]
  between: [Int!]
}

input MutateCactusSyncTimestampInput {
  _id: GraphbackObjectID!
  _clientId: GraphbackObjectID
  timestamp: Int
  changeType: DatabaseChangeType
  modelTypename: String
  modelId: GraphbackObjectID
}

input MutateTodoInput {
  _id: GraphbackObjectID!
  _clientId: GraphbackObjectID
  _version: Int
  _lastUpdatedAt: Int
  title: String
  userId: GraphbackObjectID
}

input MutateUserInput {
  _id: GraphbackObjectID!
  _clientId: GraphbackObjectID
  _version: Int
  _lastUpdatedAt: Int
  name: String
}

type Mutation {
  createTodo(input: CreateTodoInput!): Todo
  updateTodo(input: MutateTodoInput!): Todo
  deleteTodo(input: MutateTodoInput!): Todo
  createUser(input: CreateUserInput!): User
  updateUser(input: MutateUserInput!): User
  deleteUser(input: MutateUserInput!): User
  createCactusSyncTimestamp(input: CreateCactusSyncTimestampInput!): CactusSyncTimestamp
  updateCactusSyncTimestamp(input: MutateCactusSyncTimestampInput!): CactusSyncTimestamp
  deleteCactusSyncTimestamp(input: MutateCactusSyncTimestampInput!): CactusSyncTimestamp
}

input OrderByInput {
  field: String!
  order: SortDirectionEnum = ASC
}

input PageRequest {
  limit: Int
  offset: Int
}

type Query {
  getTodo(id: GraphbackObjectID!): Todo
  findTodos(filter: TodoFilter, page: PageRequest, orderBy: OrderByInput): TodoResultList!
  getUser(id: GraphbackObjectID!): User
  findUsers(filter: UserFilter, page: PageRequest, orderBy: OrderByInput): UserResultList!
  getCactusSyncTimestamp(id: GraphbackObjectID!): CactusSyncTimestamp
  findCactusSyncTimestamps(filter: CactusSyncTimestampFilter, page: PageRequest, orderBy: OrderByInput): CactusSyncTimestampResultList!
}

enum SortDirectionEnum {
  DESC
  ASC
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String!]
  contains: String
  startsWith: String
  endsWith: String
}

type Subscription {
  newTodo(filter: TodoSubscriptionFilter): Todo!
  updatedTodo(filter: TodoSubscriptionFilter): Todo!
  deletedTodo(filter: TodoSubscriptionFilter): Todo!
  newUser(filter: UserSubscriptionFilter): User!
  updatedUser(filter: UserSubscriptionFilter): User!
  deletedUser(filter: UserSubscriptionFilter): User!
  newCactusSyncTimestamp(filter: CactusSyncTimestampSubscriptionFilter): CactusSyncTimestamp!
  updatedCactusSyncTimestamp(filter: CactusSyncTimestampSubscriptionFilter): CactusSyncTimestamp!
  deletedCactusSyncTimestamp(filter: CactusSyncTimestampSubscriptionFilter): CactusSyncTimestamp!
}

"""
@model
@cactusSync
TODO: make directive hasId
@hasId
"""
type Todo {
  _id: GraphbackObjectID!

  """
  The id, which will be created, if
  the model was created offline
  """
  _clientId: GraphbackObjectID
  _version: Int!
  _lastUpdatedAt: Int!
  title: String

  """
  @manyToOne(field: 'todos', key: 'userId')
  @manyToOne(field: 'todos')
  """
  user: User
}

input TodoFilter {
  _id: GraphbackObjectIDInput
  _clientId: GraphbackObjectIDInput
  _version: IntInput
  _lastUpdatedAt: IntInput
  title: StringInput
  userId: GraphbackObjectIDInput
  and: [TodoFilter!]
  or: [TodoFilter!]
  not: TodoFilter
}

type TodoResultList {
  items: [Todo]!
  offset: Int
  limit: Int
  count: Int
}

input TodoSubscriptionFilter {
  and: [TodoSubscriptionFilter!]
  or: [TodoSubscriptionFilter!]
  not: TodoSubscriptionFilter
  _id: GraphbackObjectIDInput
  _clientId: GraphbackObjectIDInput
  _version: IntInput
  _lastUpdatedAt: IntInput
  title: StringInput
}

"""
@model
@cactusSync
"""
type User {
  _id: GraphbackObjectID!

  """
  The id, which will be created, if
  the model was created offline
  """
  _clientId: GraphbackObjectID
  _version: Int!
  _lastUpdatedAt: Int!
  name: String

  """
  @oneToMany(field: 'user', key: 'userId')
  @oneToMany(field: 'user')
  """
  todos(filter: TodoFilter): [Todo]!
}

input UserFilter {
  _id: GraphbackObjectIDInput
  _clientId: GraphbackObjectIDInput
  _version: IntInput
  _lastUpdatedAt: IntInput
  name: StringInput
  and: [UserFilter!]
  or: [UserFilter!]
  not: UserFilter
}

type UserResultList {
  items: [User]!
  offset: Int
  limit: Int
  count: Int
}

input UserSubscriptionFilter {
  and: [UserSubscriptionFilter!]
  or: [UserSubscriptionFilter!]
  not: UserSubscriptionFilter
  _id: GraphbackObjectIDInput
  _clientId: GraphbackObjectIDInput
  _version: IntInput
  _lastUpdatedAt: IntInput
  name: StringInput
}